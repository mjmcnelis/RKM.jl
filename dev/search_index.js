var documenterSearchIndex = {"docs":
[{"location":"methods/runge_kutta/explicit/medium_order.html#Medium-order-(4-6)-explicit-Runge-Kutta-methods","page":"Medium-order","title":"Medium-order (4-6) explicit Runge-Kutta methods","text":"","category":"section"},{"location":"methods/runge_kutta/explicit/medium_order.html#Standard","page":"Medium-order","title":"Standard","text":"","category":"section"},{"location":"methods/runge_kutta/explicit/medium_order.html","page":"Medium-order","title":"Medium-order","text":"The following standard methods are compatible with Fixed(), Doubling() and FiniteDiff() time-stepping:","category":"page"},{"location":"methods/runge_kutta/explicit/medium_order.html","page":"Medium-order","title":"Medium-order","text":"RungeKutta4(): Runge and Kutta's classic fourth-order method\nThreeEightsRule4(): fourth-order 3/8 rule\nRalston4(): Ralston's fourth-order method\nKetcheson4(): Ketcheson's fourth-order SSP method\nButcher5(): Butcher's fifth-order method\nButcher6(): Butcher's sixth-order method","category":"page"},{"location":"methods/runge_kutta/explicit/medium_order.html#Embedded","page":"Medium-order","title":"Embedded","text":"","category":"section"},{"location":"methods/runge_kutta/explicit/medium_order.html","page":"Medium-order","title":"Medium-order","text":"The following embedded methods are compatible with all adaptive time step options:","category":"page"},{"location":"methods/runge_kutta/explicit/medium_order.html","page":"Medium-order","title":"Medium-order","text":"Fehlberg5(): Fehlberg's fifth-order method\nCashKarp5(): Cash and Karp's fifth-order method\nDormandPrince5(): Dormand and Prince's fifth-order method\nBogackiShampine5(): Bogacki and Shampine's fifth-order method\nTsitouras5(): Bogacki and Shampine's fifth-order method\nVerner5(): Verner's fifth-order method\nVerner6(): Verner's sixth-order method","category":"page"},{"location":"methods/runge_kutta/explicit/medium_order.html","page":"Medium-order","title":"Medium-order","text":"Note: SSP stands for strong stability preserving","category":"page"},{"location":"methods/runge_kutta/explicit/medium_order.html#API-Reference","page":"Medium-order","title":"API Reference","text":"","category":"section"},{"location":"methods/runge_kutta/explicit/medium_order.html#RKM.BogackiShampine5-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T<:AbstractFloat","page":"Medium-order","title":"RKM.BogackiShampine5","text":"BogackiShampine5(precision::Type{T} = Float64) where T <: AbstractFloat\n\nBogacki and Shampine's fifth-order method.\n\n\n\n\n\n","category":"method"},{"location":"methods/runge_kutta/explicit/medium_order.html#RKM.Butcher5-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T<:AbstractFloat","page":"Medium-order","title":"RKM.Butcher5","text":"Butcher5(precision::Type{T} = Float64) where T <: AbstractFloat\n\nButcher's fifth-order method.\n\n\n\n\n\n","category":"method"},{"location":"methods/runge_kutta/explicit/medium_order.html#RKM.Butcher6-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T<:AbstractFloat","page":"Medium-order","title":"RKM.Butcher6","text":"Butcher6(precision::Type{T} = Float64) where T <: AbstractFloat\n\nButcher's sixth-order method.\n\n\n\n\n\n","category":"method"},{"location":"methods/runge_kutta/explicit/medium_order.html#RKM.CashKarp5-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T<:AbstractFloat","page":"Medium-order","title":"RKM.CashKarp5","text":"CashKarp5(precision::Type{T} = Float64) where T <: AbstractFloat\n\nCash and Karp's fifth-order method.\n\nhttp://www.elegio.it/mc2/rk/doc/p201-cash-karp.pdf\n\n\n\n\n\n","category":"method"},{"location":"methods/runge_kutta/explicit/medium_order.html#RKM.DormandPrince5-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T<:AbstractFloat","page":"Medium-order","title":"RKM.DormandPrince5","text":"DormandPrince5(precision::Type{T} = Float64) where T <: AbstractFloat\n\nDormand and Prince's fifth-order method.\n\nhttps://www.sciencedirect.com/science/article/pii/0771050X80900133?via%3Dihub https://www.sciencedirect.com/science/article/pii/0898122186900258\n\n\n\n\n\n","category":"method"},{"location":"methods/runge_kutta/explicit/medium_order.html#RKM.Fehlberg5-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T<:AbstractFloat","page":"Medium-order","title":"RKM.Fehlberg5","text":"Fehlberg5(precision::Type{T} = Float64) where T <: AbstractFloat\n\nFehlberg's fifth-order method.\n\nhttps://ntrs.nasa.gov/citations/19690021375\n\n\n\n\n\n","category":"method"},{"location":"methods/runge_kutta/explicit/medium_order.html#RKM.Ketcheson4-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T<:AbstractFloat","page":"Medium-order","title":"RKM.Ketcheson4","text":"Ketcheson4(precision::Type{T} = Float64) where T <: AbstractFloat\n\nKetcheson's fourth-order SSP method.\n\nhttps://epubs.siam.org/doi/10.1137/07070485X\n\n\n\n\n\n","category":"method"},{"location":"methods/runge_kutta/explicit/medium_order.html#RKM.Ralston4-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T<:AbstractFloat","page":"Medium-order","title":"RKM.Ralston4","text":"Ralston4(precision::Type{T} = Float64) where T <: AbstractFloat\n\nRalston's fourth-order method.\n\nhttps://www.ams.org/journals/mcom/1962-16-080/S0025-5718-1962-0150954-0/S0025-5718-1962-0150954-0.pdf\n\n\n\n\n\n","category":"method"},{"location":"methods/runge_kutta/explicit/medium_order.html#RKM.RungeKutta4-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T<:AbstractFloat","page":"Medium-order","title":"RKM.RungeKutta4","text":"RungeKutta4(precision::Type{T} = Float64) where T <: AbstractFloat\n\nClassic fourth-order Runge-Kutta method.\n\n\n\n\n\n","category":"method"},{"location":"methods/runge_kutta/explicit/medium_order.html#RKM.ThreeEightsRule4-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T<:AbstractFloat","page":"Medium-order","title":"RKM.ThreeEightsRule4","text":"ThreeEightsRule4(precision::Type{T} = Float64) where T <: AbstractFloat\n\nFourth-order 3/8 rule.\n\n\n\n\n\n","category":"method"},{"location":"methods/runge_kutta/explicit/medium_order.html#RKM.Tsitouras5-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T<:AbstractFloat","page":"Medium-order","title":"RKM.Tsitouras5","text":"Tsitouras5(precision::Type{T} = Float64) where T <: AbstractFloat\n\nTsitouras' fifth-order method.\n\nhttps://www.sciencedirect.com/science/article/pii/S0898122111004706\n\n\n\n\n\n","category":"method"},{"location":"methods/runge_kutta/explicit/medium_order.html#RKM.Verner5-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T<:AbstractFloat","page":"Medium-order","title":"RKM.Verner5","text":"Verner5(precision::Type{T} = Float64) where T <: AbstractFloat\n\nVerner's fifth-order method (1978).\n\nhttps://www.jstor.org/stable/2156853\n\n\n\n\n\n","category":"method"},{"location":"methods/runge_kutta/explicit/medium_order.html#RKM.Verner6-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T<:AbstractFloat","page":"Medium-order","title":"RKM.Verner6","text":"Verner6(precision::Type{T} = Float64) where T <: AbstractFloat\n\nVerner's sixth-order method.\n\nhttps://link.springer.com/book/10.1007/978-3-540-78862-1\n\n\n\n\n\n","category":"method"},{"location":"solution/dense_output.html#Dense-output","page":"Dense output","title":"Dense output","text":"","category":"section"},{"location":"solution/dense_output.html","page":"Dense output","title":"Dense output","text":"Interpolation can only be performed after solving the ODE, since it uses raw solution data as input. In addition to the state variables, the cubic Hermite and continuous formula routines use time derivative and intermediate stage data, respectively. You will need to change the solver option interpolator to solve and store the solution variables required by each routine.","category":"page"},{"location":"solution/dense_output.html#No-interpolation","page":"Dense output","title":"No interpolation","text":"","category":"section"},{"location":"solution/dense_output.html","page":"Dense output","title":"Dense output","text":"If you do not plan to interpolate the solution, use the default value interpolator = NoInterpolator(). The solver will only output the time series and state variables of the raw solution.","category":"page"},{"location":"solution/dense_output.html#Cubic-Hermite","page":"Dense output","title":"Cubic Hermite","text":"","category":"section"},{"location":"solution/dense_output.html","page":"Dense output","title":"Dense output","text":"All ODE methods can use cubic Hermite interpolation to generate dense output. Here, we continue with the overdamped oscillator example and set the solver option interpolator = CubicHermite(). The solver will output the time derivatives, which is stored in sol.f.","category":"page"},{"location":"solution/dense_output.html","page":"Dense output","title":"Dense output","text":"using RKM\nusing Plots; plotly()\n\nfunction dy_dt!(f, y, t; p, kwargs...)\n    γ = p[1]\n    ω = p[2]\n    f[1] = y[2]\n    f[2] = -γ*y[2] - ω^2*y[1]\n    return nothing\nend\n\ny0 = [1.0, -1.0]  # [position, velocity]\nt0 = 0.0\ntf = 10.0\ndt0 = 1e-2\n\nγ = 101.0         # damping coefficient\nω = 10.0          # frequency\np = [γ, ω]\n\noptions = SolverOptions(; method = TrapezoidRuleBDF2(),\n                          adaptive = Embedded(; alpha = 1e-3),\n                          interpolator = CubicHermite(),);\n\nsol = evolve_ode(y0, t0, tf, dt0, dy_dt!, options, p);","category":"page"},{"location":"solution/dense_output.html","page":"Dense output","title":"Dense output","text":"First, we plot the non-uniform solution data from the adaptive TRBDF2 method:","category":"page"},{"location":"solution/dense_output.html","page":"Dense output","title":"Dense output","text":"t, y = get_solution(sol);\nscatter(t, y; xlabel = \"t\", ylabel = \"y\", label = [\"x\" \"v\"], color = [:red :blue], ms = 3)","category":"page"},{"location":"solution/dense_output.html","page":"Dense output","title":"Dense output","text":"<img src=\"images/scatter_plot.png\" width=\"600\">","category":"page"},{"location":"solution/dense_output.html","page":"Dense output","title":"Dense output","text":"Next, we call interpolate_solution to interpolate the data uniformly (the keyword argument dt_dense controls the temporal spacing).","category":"page"},{"location":"solution/dense_output.html","page":"Dense output","title":"Dense output","text":"t_dense, y_dense = interpolate_solution(options, sol; dt_dense = 1e-4);\nplot!(t_dense, y_dense; label = [\"x (dense)\" \"v (dense)\"], color = [:red :blue])","category":"page"},{"location":"solution/dense_output.html","page":"Dense output","title":"Dense output","text":"The interpolated solution is C^1 continuous and third-order accurate (i.e. it has a local error of mathcalO(Delta t_n^4) between the raw time intervals t_n t_n+1).","category":"page"},{"location":"solution/dense_output.html","page":"Dense output","title":"Dense output","text":"<img src=\"images/hermite_plot.png\" width=\"600\">","category":"page"},{"location":"solution/dense_output.html#Continuous-formula","page":"Dense output","title":"Continuous formula","text":"","category":"section"},{"location":"solution/dense_output.html","page":"Dense output","title":"Dense output","text":"If the ODE method has a continuous formula that uses intermediate stages, you can set interpolator = ContinuousFormula(). After solving the ODE, the intermediate stage data will be stored in sol.dy.","category":"page"},{"location":"solution/dense_output.html","page":"Dense output","title":"Dense output","text":"options = SolverOptions(; method = TrapezoidRuleBDF2(),\n                          adaptive = Embedded(; alpha = 1e-3),\n                          interpolator = ContinuousFormula(),);\n\nsol = evolve_ode(y0, t0, tf, dt0, dy_dt!, options, p);","category":"page"},{"location":"solution/dense_output.html","page":"Dense output","title":"Dense output","text":"Then call interpolate_solution to use the continuous formula. The function also displays the formula's order and degree of continuity (either C^0 or C^1).","category":"page"},{"location":"solution/dense_output.html","page":"Dense output","title":"Dense output","text":"julia> t_dense, y_dense = interpolate_solution(options, sol; dt_dense = 1e-4);\n[ Info: Generating order-2 C0 continuous output for TrapezoidRuleBDF2","category":"page"},{"location":"solution/dense_output.html","page":"Dense output","title":"Dense output","text":"The TRBDF2 continuous formula is less accurate and smooth than cubic Hermite interpolation, but it qualitatively produces the same curves:","category":"page"},{"location":"solution/dense_output.html","page":"Dense output","title":"Dense output","text":"t, y = get_solution(sol);\nscatter(t, y; xlabel = \"t\", ylabel = \"y\", label = [\"x\" \"v\"], color = [:red :blue], ms = 3);\nplot!(t_dense, y_dense; label = [\"x (dense)\" \"v (dense)\"], color = [:red :blue])","category":"page"},{"location":"solution/dense_output.html","page":"Dense output","title":"Dense output","text":"<img src=\"images/continuous_plot.png\" width=\"600\">","category":"page"},{"location":"solution/dense_output.html#Compatibility-with-step-doubling","page":"Dense output","title":"Compatibility with step-doubling","text":"","category":"section"},{"location":"solution/dense_output.html","page":"Dense output","title":"Dense output","text":"You can still use the continuous formula if you used step-doubling for the adaptive time step. However, the raw solution's global accuracy is reduced by one order (the solver updates the state with a regular time step instead of an extrapolated step).","category":"page"},{"location":"solution/dense_output.html","page":"Dense output","title":"Dense output","text":"options = SolverOptions(; method = TrapezoidRuleBDF2(),\n                          adaptive = Doubling(),\n                          interpolator = ContinuousFormula(),);\n\nsol = evolve_ode(y0, t0, tf, dt0, dy_dt!, options, p);\n\nt, y = get_solution(sol);\nt_dense, y_dense = interpolate_solution(options, sol; dt_dense = 1e-4);\n\nscatter(t, y; xlabel = \"t\", ylabel = \"y\", label = [\"x\" \"v\"], color = [:red :blue], ms = 3);\nplot!(t_dense, y_dense; label = [\"x (dense)\" \"v (dense)\"], color = [:red :blue])","category":"page"},{"location":"solution/dense_output.html","page":"Dense output","title":"Dense output","text":"<img src=\"images/continuous_plot_2.png\" width=\"600\">","category":"page"},{"location":"solution/dense_output.html","page":"Dense output","title":"Dense output","text":"We recommend using the continuous formula with an embedded Runge-Kutta method instead.","category":"page"},{"location":"methods/runge_kutta/tableau.html#Method-construction","page":"Method construction","title":"Method construction","text":"","category":"section"},{"location":"methods/runge_kutta/tableau.html","page":"Method construction","title":"Method construction","text":"In this section, we discuss how a Runge-Kutta method's Butcher tableau and properties are constructed and stored in the RungeKutta struct.","category":"page"},{"location":"methods/runge_kutta/tableau.html#Example","page":"Method construction","title":"Example","text":"","category":"section"},{"location":"methods/runge_kutta/tableau.html","page":"Method construction","title":"Method construction","text":"Here we set the ODE solver method to the classic fourth-order Runge-Kutta method:","category":"page"},{"location":"methods/runge_kutta/tableau.html","page":"Method construction","title":"Method construction","text":"method = RungeKutta4()","category":"page"},{"location":"methods/runge_kutta/tableau.html","page":"Method construction","title":"Method construction","text":"The code for this method's constructor is","category":"page"},{"location":"methods/runge_kutta/tableau.html","page":"Method construction","title":"Method construction","text":"function RungeKutta4(precision::Type{T} = Float64) where T <: AbstractFloat\n    butcher = [0 0 0 0 0\n               1//2 1//2 0 0 0\n               1//2 0 1//2 0 0\n               1 0 0 1 0\n               1 1//6 1//3 1//3 1//6]\n    butcher = butcher .|> precision\n\n    return RungeKutta(; name = :Runge_Kutta_4, butcher)\nend","category":"page"},{"location":"methods/runge_kutta/tableau.html","page":"Method construction","title":"Method construction","text":"First we write out the Butcher tableau in Matrix form. If the coefficients are simple, we express them as integers and fractions (otherwise we use big strings). The matrix butcher is converted to the float type precision, which is set by the user.","category":"page"},{"location":"methods/runge_kutta/tableau.html","page":"Method construction","title":"Method construction","text":"Next, we pass butcher and a symbolic label name to RungeKutta's outer constructor. The outer constructor partitions butcher into the arrays c, A_T and b (b_hat) and stores them as static types. It also infers several properties, such as the number of stages and whether the method is explicit or implicit. The order of the primary (embedded) update is extracted by parsing name. The code below shows the fields of the RungeKutta struct method after it is set to RungeKutta4():","category":"page"},{"location":"methods/runge_kutta/tableau.html","page":"Method construction","title":"Method construction","text":"julia> for field in method |> typeof |> fieldnames\n           println(\"$field = $(getproperty(method, field))\")\n       end\nname = Runge_Kutta_4\nc = [0.0, 0.5, 0.5, 1.0]\nA_T = [0.0 0.5 0.0 0.0; 0.0 0.0 0.5 0.0; 0.0 0.0 0.0 1.0; 0.0 0.0 0.0 0.0]\nb = [0.16666666666666666, 0.3333333333333333, 0.3333333333333333, 0.16666666666666666]\nb_hat = [0.16666666666666666, 0.3333333333333333, 0.3333333333333333, 0.16666666666666666]\nstages = 4\norder = [4.0]\niteration = Explicit()\nfesal = false\ncode_name = RK4","category":"page"},{"location":"methods/runge_kutta/tableau.html","page":"Method construction","title":"Method construction","text":"Note: the 1 entry in the lower-left corner of butcher is only used as a placeholder to verify that the coefficients in b (b_hat) sum up to unity within floating precision.","category":"page"},{"location":"methods/runge_kutta/tableau.html#API-Reference","page":"Method construction","title":"API Reference","text":"","category":"section"},{"location":"methods/runge_kutta/tableau.html#RKM.RungeKutta","page":"Method construction","title":"RKM.RungeKutta","text":"struct RungeKutta{T, S, S2, E, SE, R, Q, RQ, P, I, F} <: RKM.ODEMethod\n\nStores the Butcher tableau and properties of a given Runge-Kutta method.\n\nFields\n\nname::Symbol: Name of the Runge-Kutta method\nc::StaticArraysCore.SVector{S, T} where {T, S}: Intermediate time update coefficient of each stage in the Butcher tableau\nA_T::StaticArraysCore.SMatrix{S, S, T} where {T, S}: Transposed intermediate state update coefficients of each stage in the Butcher tableau\nb::StaticArraysCore.SVector{S, T} where {T, S}: Primary state update coefficients of the Butcher tableau\nb_hat::StaticArraysCore.SMatrix{E, S, T} where {T, S, E}: Embedded state update coefficients (if any) of the Butcher tableau\nω::StaticArraysCore.SMatrix{R, Q, T} where {T, R, Q}: Polynomial coefficients used for continuous output\nstages::Int64: Number of stages in the Runge-Kutta method\norder::StaticArraysCore.SVector{P, T} where {T, P}: Order of the primary (and embedded) update(s) of the Runge-Kutta method\niteration::Any: Determines whether the method is explicit or full/diagonal implicit\nfesal::Bool: Determines whether the method has the FESAL property (see ../properties/fesal.jl)\nexplicit_stage::StaticArraysCore.SVector{S, Bool} where S: Determines which stages are explicit\ncode_name::String: Abbreviated name for the Runge-Kutta method\nreconstructor::Any: Function used to reconstruct Runge-Kutta method\n\n\n\n\n\n","category":"type"},{"location":"methods/runge_kutta/tableau.html#RKM.RungeKutta-Union{Tuple{RQ}, Tuple{Q}, Tuple{R}, Tuple{NM}, Tuple{M}, Tuple{N}, Tuple{T}, Tuple{Symbol, StaticArraysCore.SMatrix{N, M, T, NM}, Iteration, Function}} where {T<:AbstractFloat, N, M, NM, R, Q, RQ}","page":"Method construction","title":"RKM.RungeKutta","text":"RungeKutta(name::Symbol, butcher::SMatrix{N, M, T, NM},\n           iteration::Iteration, reconstructor::Function;\n           ω::SMatrix{R, Q, T, RQ} = SMatrix{0,0,T,0}()\n          ) where {T <: AbstractFloat, N, M, NM, R, Q, RQ}\n\nOuter constructor for RungeKutta.\n\nRequired parameters: name, butcher, iteration, reconstructor\n\nNote: ω are interpolation coefficients used for continuous output,       but some methods may not have them.\n\n\n\n\n\n","category":"method"},{"location":"adaptive/constructor.html#Options-and-parameters","page":"Options and parameters","title":"Options and parameters","text":"","category":"section"},{"location":"adaptive/constructor.html#RKM.Doubling","page":"Options and parameters","title":"RKM.Doubling","text":"struct Doubling{PCB, LM} <: RKM.AdaptiveTimeStep\n\nStep doubling adaptive time step algorithm\n\nFields\n\nepsilon::Float64: Relative error tolerance\nalpha::Float64: Absolute error tolerance\ndelta::Float64: Incremental error tolerance\np_norm::Float64: Integer used to compute L–norms\nmax_attempts::Int64: Maximum number of attempts to compute time step per update\ntotal_attempts::StaticArraysCore.MVector{1, Int64}: Total number of attempts in evolution loop\nbenchmark_diffeq::Bool: Skip rescaling tolerance parameters if benchmark against OrdinaryDiffEq\npid::Any: PID controller gain parameters\nlimiter::Any: Limiter method for time step controller\ninitialized_controller::StaticArraysCore.MVector{1, Bool}: Whether the time step controller has been initialized\n\n\n\n\n\n","category":"type"},{"location":"methods/runge_kutta/explicit/low_order.html#Low-order-(1-3)-explicit-Runge-Kutta-methods","page":"Low-order","title":"Low-order (1-3) explicit Runge-Kutta methods","text":"","category":"section"},{"location":"methods/runge_kutta/explicit/low_order.html#Standard","page":"Low-order","title":"Standard","text":"","category":"section"},{"location":"methods/runge_kutta/explicit/low_order.html","page":"Low-order","title":"Low-order","text":"The following standard methods are compatible with Fixed(), Doubling() and FiniteDiff() time-stepping:","category":"page"},{"location":"methods/runge_kutta/explicit/low_order.html","page":"Low-order","title":"Low-order","text":"Euler1(): Euler's first-order method\nHeun2(): Heun's second-order SSP method\nMidpoint2(): second-order mid-point rule\nRalston2(): Ralston's second-order method\nHeun3(): Heun's third-order method\nRalston3(): Ralston's third-order\nKutta3(): Kutta's third-order method\nShuOsher3(): Shu and Osher's third-order SSP method\nSpiteriRuuth3(): Spiteri and Ruuth's third-order SSP method","category":"page"},{"location":"methods/runge_kutta/explicit/low_order.html#Embedded","page":"Low-order","title":"Embedded","text":"","category":"section"},{"location":"methods/runge_kutta/explicit/low_order.html","page":"Low-order","title":"Low-order","text":"The following embedded methods are compatible with all adaptive time step options:","category":"page"},{"location":"methods/runge_kutta/explicit/low_order.html","page":"Low-order","title":"Low-order","text":"Fehlberg2(): Fehlberg's second-order method\nHeun2(): Heun-Euler second-order method\nBogackiShampine3(): Bogacki and Shampine's third-order method","category":"page"},{"location":"methods/runge_kutta/explicit/low_order.html","page":"Low-order","title":"Low-order","text":"Note: SSP stands for strong stability preserving","category":"page"},{"location":"methods/runge_kutta/explicit/low_order.html#API-Reference","page":"Low-order","title":"API Reference","text":"","category":"section"},{"location":"methods/runge_kutta/explicit/low_order.html#RKM.BogackiShampine3-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T<:AbstractFloat","page":"Low-order","title":"RKM.BogackiShampine3","text":"BogackiShampine3(precision::Type{T} = Float64) where T <: AbstractFloat\n\nBogacki and Shampine's third-order method.\n\nhttps://www.sciencedirect.com/science/article/pii/0893965989900797\n\n\n\n\n\n","category":"method"},{"location":"methods/runge_kutta/explicit/low_order.html#RKM.Euler1-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T<:AbstractFloat","page":"Low-order","title":"RKM.Euler1","text":"Euler1(precision::Type{T} = Float64) where T <: AbstractFloat\n\nEuler's explicit first-order method.\n\n\n\n\n\n","category":"method"},{"location":"methods/runge_kutta/explicit/low_order.html#RKM.Fehlberg2-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T<:AbstractFloat","page":"Low-order","title":"RKM.Fehlberg2","text":"Fehlberg2(precision::Type{T} = Float64) where T <: AbstractFloat\n\nFehlberg's second-order method.\n\nhttps://ntrs.nasa.gov/citations/19690021375\n\n\n\n\n\n","category":"method"},{"location":"methods/runge_kutta/explicit/low_order.html#RKM.Heun2-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T<:AbstractFloat","page":"Low-order","title":"RKM.Heun2","text":"Heun2(precision::Type{T} = Float64) where T <: AbstractFloat\n\nHeun's second-order method.\n\nNote: strong stability preserving (SSP)\n\n\n\n\n\n","category":"method"},{"location":"methods/runge_kutta/explicit/low_order.html#RKM.Heun3-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T<:AbstractFloat","page":"Low-order","title":"RKM.Heun3","text":"Heun3(precision::Type{T} = Float64) where T <: AbstractFloat\n\nHeun's third-order method.\n\n\n\n\n\n","category":"method"},{"location":"methods/runge_kutta/explicit/low_order.html#RKM.Kutta3-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T<:AbstractFloat","page":"Low-order","title":"RKM.Kutta3","text":"Kutta3(precision::Type{T} = Float64) where T <: AbstractFloat\n\nKutta's third-order method.\n\n\n\n\n\n","category":"method"},{"location":"methods/runge_kutta/explicit/low_order.html#RKM.Midpoint2-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T<:AbstractFloat","page":"Low-order","title":"RKM.Midpoint2","text":"Midpoint2(precision::Type{T} = Float64) where T <: AbstractFloat\n\nSecond-order midpoint rule.\n\n\n\n\n\n","category":"method"},{"location":"methods/runge_kutta/explicit/low_order.html#RKM.Ralston2-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T<:AbstractFloat","page":"Low-order","title":"RKM.Ralston2","text":"Ralston2(precision::Type{T} = Float64) where T <: AbstractFloat\n\nRalston's second-order method.\n\nhttps://www.ams.org/journals/mcom/1962-16-080/S0025-5718-1962-0150954-0/S0025-5718-1962-0150954-0.pdf\n\n\n\n\n\n","category":"method"},{"location":"methods/runge_kutta/explicit/low_order.html#RKM.Ralston3-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T<:AbstractFloat","page":"Low-order","title":"RKM.Ralston3","text":"Ralston3(precision::Type{T} = Float64) where T <: AbstractFloat\n\nRalston's third-order method.\n\nhttps://www.ams.org/journals/mcom/1962-16-080/S0025-5718-1962-0150954-0/S0025-5718-1962-0150954-0.pdf\n\n\n\n\n\n","category":"method"},{"location":"methods/runge_kutta/explicit/low_order.html#RKM.ShuOsher3-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T<:AbstractFloat","page":"Low-order","title":"RKM.ShuOsher3","text":"ShuOsher3(precision::Type{T} = Float64) where T <: AbstractFloat\n\nShu and Osher's third-order SSP method.\n\nhttps://www.sciencedirect.com/science/article/pii/0021999188901775\n\n\n\n\n\n","category":"method"},{"location":"methods/runge_kutta/explicit/low_order.html#RKM.SpiteriRuuth3-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T<:AbstractFloat","page":"Low-order","title":"RKM.SpiteriRuuth3","text":"SpiteriRuuth3(precision::Type{T} = Float64) where T <: AbstractFloat\n\nSpiteri and Ruuth's third-order SSP method.\n\nhttps://epubs.siam.org/doi/10.1137/S0036142902419284\n\n\n\n\n\n","category":"method"},{"location":"solution/statistics.html","page":"Solver statistics","title":"Solver statistics","text":"maybe this should be a separate section...","category":"page"},{"location":"solution/statistics.html#Solver-statistics","page":"Solver statistics","title":"Solver statistics","text":"","category":"section"},{"location":"solution/statistics.html","page":"Solver statistics","title":"Solver statistics","text":"After running the ODE solver, you can print out statistics with the function get_stats:","category":"page"},{"location":"solution/statistics.html","page":"Solver statistics","title":"Solver statistics","text":"using RKM\nusing Plots; plotly()\n\nfunction dy_dt!(f, y, t; p, kwargs...)\n    γ = p[1]\n    ω = p[2]\n    f[1] = y[2]\n    f[2] = -γ*y[2] - ω^2*y[1]\n    return nothing\nend\n\ny0 = [1.0, -1.0]  # [position, velocity]\nt0 = 0.0\ntf = 10.0\ndt0 = 1e-2\n\nγ = 101.0         # damping coefficient\nω = 10.0          # frequency\np = [γ, ω]\n\noptions = SolverOptions(; method = RungeKutta4(), adaptive = Fixed(),);\n\nsol = evolve_ode(y0, t0, tf, dt0, dy_dt!, options, p);\n@time sol = evolve_ode(y0, t0, tf, dt0, dy_dt!, options, p);    # recompile\n#  0.000208 seconds (162 allocations: 34.250 KiB)","category":"page"},{"location":"solution/statistics.html","page":"Solver statistics","title":"Solver statistics","text":"julia> get_stats(sol)\ntime steps taken     = 1001\ntime points saved    = 1002\nstep rejection rate  = 0.0 %\nfunction evaluations = 4005\njacobian evaluations = 0\nevolution runtime    = 0.0001559 seconds\nsolution size        = 23.484 KiB\nsensitivity size     = 0 bytes\nconfig memory        = 8.516 KiB\nexcess memory        = 0 bytes","category":"page"},{"location":"solution/statistics.html","page":"Solver statistics","title":"Solver statistics","text":"Here we summarize each runtime statistic:","category":"page"},{"location":"solution/statistics.html","page":"Solver statistics","title":"Solver statistics","text":"Time steps taken\nthe number of steps the solver advanced with during the time evolution.\nTime points saved\nthe number of solution points saved if you chose to output them (i.e. save_solution = true)\nStep rejection rate\nthe percentage of attempted steps that were rejected if you used an adaptive time step method.\nFunction evaluations\nthe number of times the ODE function fracdvecydt = vecf(vecy t vecp) was called. This includes any function evaluations needed the compute the state and parameter Jacobians fracpartial f_ipartial y_j and fracpartial f_ipartial p_j.\nJacobian evaluations\nthe number of times the state and parameter Jacobians were evaluated if you used an implicit solver with Newton's method and/or a sensitivity method.\nEvolution runtime\nthe portion of runtime the solver took running the time evolution loop.\nSolution size\nthe amount of memory used to store the solution sol.t and sol.y. If you used an interpolator, the time derivatives sol.f or intermediate stages sol.dy are also counted.\nSensitivity size\nthe amount of memory used to store the sensitivity coefficients sol.S if you used a sensitivity method.\nConfiguration memory\nThe memory allocated to configure the solver before running the time evolution loop (mostly for intermediate caches).\nExcess memory\nThe amount of memory allocated during the time evolution loop (discounting solution storage).","category":"page"},{"location":"solution/solution_data.html#Solution-data","page":"Solution data","title":"Solution data","text":"","category":"section"},{"location":"solution/solution_data.html","page":"Solution data","title":"Solution data","text":"After solving the ODE, you can plot the time series data stored in the Solution struct sol. The following sections are based on the overdamped harmonic oscillator:","category":"page"},{"location":"solution/solution_data.html","page":"Solution data","title":"Solution data","text":"beginalign*\nfracdxdt = v \nfracdvdt = -gamma v - omega^2 x\nendalign*","category":"page"},{"location":"solution/solution_data.html","page":"Solution data","title":"Solution data","text":"where x and v are the position and velocity, and gamma and omega are the damping coefficient and frequency.","category":"page"},{"location":"solution/solution_data.html","page":"Solution data","title":"Solution data","text":"using RKM\nusing Plots; plotly()\n\nfunction dy_dt!(f, y, t; p, kwargs...)\n    γ = p[1]\n    ω = p[2]\n    f[1] = y[2]\n    f[2] = -γ*y[2] - ω^2*y[1]\n    return nothing\nend\n\ny0 = [1.0, -1.0]  # [position, velocity]\nt0 = 0.0\ntf = 10.0\ndt0 = 1e-2\n\nγ = 101.0         # damping coefficient\nω = 10.0          # frequency\np = [γ, ω]\n\noptions = SolverOptions(; method = RungeKutta4(), adaptive = Fixed(),);\n\nsol = evolve_ode(y0, t0, tf, dt0, dy_dt!, options, p);","category":"page"},{"location":"solution/solution_data.html#Time-and-state-variables","page":"Solution data","title":"Time and state variables","text":"","category":"section"},{"location":"solution/solution_data.html","page":"Solution data","title":"Solution data","text":"The time series t = (t_0  t_n) is stored in sol.t. The state variables sol.y are stored in linear column format as vecy(t) = (vecy_0  vecy_n).","category":"page"},{"location":"solution/solution_data.html","page":"Solution data","title":"Solution data","text":"julia> sol.t\n1002-element Vector{Float64}:\n  0.0\n  ⋮\n 10.0\njulia> sol.y\n2004-element Vector{Float64}:\n  1.0\n -1.0\n  ⋮\n  4.5399929800627256e-5\n -4.5399929800627256e-5","category":"page"},{"location":"solution/solution_data.html","page":"Solution data","title":"Solution data","text":"To plot the state variables versus time, we reshape sol.y into a transposed matrix by calling the function get_solution:","category":"page"},{"location":"solution/solution_data.html","page":"Solution data","title":"Solution data","text":"julia> t, y = get_solution(sol);\njulia> y\n1002×2 transpose(::Matrix{Float64}) with eltype Float64:\n 1.0         -1.0\n ⋮\n 4.53999e-5  -4.53999e-5","category":"page"},{"location":"solution/solution_data.html","page":"Solution data","title":"Solution data","text":"Each column in y corresponds to the time series solution of each state variable. Then you can plot the solution with","category":"page"},{"location":"solution/solution_data.html","page":"Solution data","title":"Solution data","text":"plot(t, y; xlabel = \"t\", ylabel = \"y\", label = [\"x\" \"v\"])","category":"page"},{"location":"solution/solution_data.html","page":"Solution data","title":"Solution data","text":"<img src=\"images/y_plot.png\" width=\"600\">","category":"page"},{"location":"solution/solution_data.html#Time-derivatives","page":"Solution data","title":"Time derivatives","text":"","category":"section"},{"location":"solution/solution_data.html","page":"Solution data","title":"Solution data","text":"You can save the first-order time derivatives vecf = dvecydt by setting the solver option  save_time_derivative = true.","category":"page"},{"location":"solution/solution_data.html","page":"Solution data","title":"Solution data","text":"options = SolverOptions(; method = RungeKutta4(), adaptive = Fixed(),\n                          save_time_derivative = true,);\n\nsol = evolve_ode(y0, t0, tf, dt0, dy_dt!, options, p);","category":"page"},{"location":"solution/solution_data.html","page":"Solution data","title":"Solution data","text":"Note: using the solver option interpolator = CubicHermite() will also output the time derivatives.","category":"page"},{"location":"solution/solution_data.html","page":"Solution data","title":"Solution data","text":"The time derivative data is stored in sol.f as a linear column (same as sol.y). You can plot them by doing","category":"page"},{"location":"solution/solution_data.html","page":"Solution data","title":"Solution data","text":"t, f = get_time_derivative(sol);\nplot(t, f; xlabel = \"t\", ylabel = \"f\", label = [\"dx/dt\" \"dv/dt\"])","category":"page"},{"location":"solution/solution_data.html","page":"Solution data","title":"Solution data","text":"<img src=\"images/f_plot.png\" width=\"600\">","category":"page"},{"location":"solution/solution_data.html#Sensitivity-coefficients","page":"Solution data","title":"Sensitivity coefficients","text":"","category":"section"},{"location":"solution/solution_data.html","page":"Solution data","title":"Solution data","text":"If you used the solver option sensitivity = DecoupledDirect(), you can plot the first-order sensitivity coefficients vecS_j = partialvecypartial p_j.","category":"page"},{"location":"solution/solution_data.html","page":"Solution data","title":"Solution data","text":"options = SolverOptions(; method = RungeKutta4(), adaptive = Fixed(),\n                          sensitivity = DecoupledDirect(),);\n\nsol = evolve_ode(y0, t0, tf, dt0, dy_dt!, options, p);","category":"page"},{"location":"solution/solution_data.html","page":"Solution data","title":"Solution data","text":"The sensitivity coefficients are stored in sol.S as a linear column. After reshaping it, you get","category":"page"},{"location":"solution/solution_data.html","page":"Solution data","title":"Solution data","text":"julia> t, S = get_sensitivity(sol);\njulia> S\n1002×4 transpose(::Matrix{Float64}) with eltype Float64:\n 0.0          0.0          0.0         0.0\n ⋮\n 4.58122e-6  -4.12263e-6  -9.16244e-5  8.24527e-5","category":"page"},{"location":"solution/solution_data.html","page":"Solution data","title":"Solution data","text":"The first two columns are the state variables' sensitivity to the first parameter γ (the last two columns are the sensitivity w.r.t. the second parameter ω).","category":"page"},{"location":"solution/solution_data.html","page":"Solution data","title":"Solution data","text":"plot(t, S; xlabel = \"t\", ylabel = \"S\", label = [\"dx/dγ\" \"dv/dγ\" \"dx/dω\" \"dv/dω\"])","category":"page"},{"location":"solution/solution_data.html","page":"Solution data","title":"Solution data","text":"<img src=\"images/S_plot.png\" width=\"600\">","category":"page"},{"location":"solution/solution_data.html#API-Reference","page":"Solution data","title":"API Reference","text":"","category":"section"},{"location":"solution/solution_data.html#RKM.Solution","page":"Solution data","title":"RKM.Solution","text":"Stores the solution vector y(t) of the ODE system in linear column format.\n\nFor example, the solution set {y(0.0) = [1.0, 2.0, 3.0], y(0.5) = [4.0, 5.0, 6.0]} is stored as y = [1.0, 2.0, 3.0, 4.0, 5.0, 6.0], t = [0.0, 0.5].\n\n\n\n\n\n","category":"type"},{"location":"solution/solution_data.html#RKM.Solution-Union{Tuple{Type{T}}, Tuple{T}} where T<:AbstractFloat","page":"Solution data","title":"RKM.Solution","text":"Solution(precision::Type{T}) where T <: AbstractFloat\n\nOuter constructor for Solution.\n\nRequired parameters: precision\n\n\n\n\n\n","category":"method"},{"location":"solution/solution_data.html#RKM.get_solution-Tuple{Solution}","page":"Solution data","title":"RKM.get_solution","text":"get_solution(sol::Solution)\n\nReturns the solution tuple (t,y) from sol. The solution vector y, which has a length D*N, is reshaped into an N x D matrix (N = time steps, D = dimensions).\n\nFor example, the solution set {y(0.0) = [1.0, 2.0, 3.0], y(0.5) = [4.0, 5.0, 6.0]} is stored in linear column format as y = [1.0, 2.0, 3.0, 4.0, 5.0, 6.0]. The solution vector is then reshaped as y = [1.0 2.0 3.0; 4.0 5.0 6.0].\n\n\n\n\n\n","category":"method"},{"location":"solution/solution_data.html#RKM.sizehint_solution!-Union{Tuple{T}, Tuple{Fixed, RKM.Interpolator, Solution, T, T, T, RKM.SensitivityMethod, Bool, Int64, Iteration, RKM.EigenMaxMethod}} where T<:AbstractFloat","page":"Solution data","title":"RKM.sizehint_solution!","text":"sizehint_solution!(adaptive::Fixed, interpolator::Interpolator, sol::Solution,\n                   t0::T, tf::T, dt::T, sensitivity::SensitivityMethod,\n                   save_time_derivative::Bool, stages::Int64\n                   iteration::Iteration,\n                   eigenmax::EigenMaxMethod) where T <: AbstractFloat\n\nApplies sizehint! to the time t and state variables y in the solution sol. The time derivative f, intermediate stages dy, sensitivity coefficients S and max eigenvalue lamnda_LR are also size-hinted if they are being outputted.\n\nRequired parameters: adaptive, interpolator, sol, t0, tf, dt, sensitivity,                      save_time_derivative, stages, iteration, eigenmax\n\n\n\n\n\n","category":"method"},{"location":"adaptive/algorithms/doubling.html#Step-doubling","page":"Step doubling","title":"Step doubling","text":"","category":"section"},{"location":"methods/runge_kutta/implicit/low_order.html#Low-order-(1-3)-implicit-Runge-Kutta-methods","page":"Low-order","title":"Low-order (1-3) implicit Runge-Kutta methods","text":"","category":"section"},{"location":"methods/runge_kutta/implicit/low_order.html#Standard","page":"Low-order","title":"Standard","text":"","category":"section"},{"location":"methods/runge_kutta/implicit/low_order.html","page":"Low-order","title":"Low-order","text":"Currently, only the standard diagonal implicit methods are compatible with Fixed() time-stepping.","category":"page"},{"location":"methods/runge_kutta/implicit/low_order.html","page":"Low-order","title":"Low-order","text":"BackwardEuler1(): first-order backward Euler method (L-stable)\nImplicitTrapezoid2(): second-order implicit trapezoid rule (A-stable)\nImplicitMidpoint2(): second-order implicit mid-point rule (symplectic, A-stable)\nQinZhang2(): Qin and Zhang's second-order method\nKraaijevangerSpijker2(): Kraaijevanger and Spijker's second-order method\nPareschiRusso2(): Pareschi and Russo's second-order method\nPareschiRusso3(): Pareschi and Russo's third-order method\nCrouzeix3(): Crouzeix's third-order method\nRadauIA3(): Radau IA3 third-order method\nRadauIIA3(): Radau IA3 third-order method\nDIRKL3(): a third-order L-stable diagonal implicit method (name unknown)","category":"page"},{"location":"methods/runge_kutta/implicit/low_order.html#API-Reference","page":"Low-order","title":"API Reference","text":"","category":"section"},{"location":"methods/runge_kutta/implicit/low_order.html#RKM.BackwardEuler1-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T<:AbstractFloat","page":"Low-order","title":"RKM.BackwardEuler1","text":"BackwardEuler1(precision::Type{T} = Float64) where T <: AbstractFloat\n\nFirst-order backward Euler method (L-stable).\n\n\n\n\n\n","category":"method"},{"location":"methods/runge_kutta/implicit/low_order.html#RKM.Crouzeix3-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T<:AbstractFloat","page":"Low-order","title":"RKM.Crouzeix3","text":"Crouzeix3(precision::Type{T} = Float64) where T <: AbstractFloat\n\nCrouzeix's third-order method.\n\n\n\n\n\n","category":"method"},{"location":"methods/runge_kutta/implicit/low_order.html#RKM.DIRKL3-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T<:AbstractFloat","page":"Low-order","title":"RKM.DIRKL3","text":"DIRKL3(precision::Type{T} = Float64) where T <: AbstractFloat\n\nThird-order L-stable diagonal implicit method.\n\nhttps://en.wikipedia.org/wiki/ListofRunge%E2%80%93Kutta_methods\n\n\n\n\n\n","category":"method"},{"location":"methods/runge_kutta/implicit/low_order.html#RKM.ImplicitMidpoint2-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T<:AbstractFloat","page":"Low-order","title":"RKM.ImplicitMidpoint2","text":"ImplicitMidpoint2(precision::Type{T} = Float64) where T <: AbstractFloat\n\nSecond-order implicit mid-point rule (A-stable).\n\n\n\n\n\n","category":"method"},{"location":"methods/runge_kutta/implicit/low_order.html#RKM.ImplicitTrapezoid2-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T<:AbstractFloat","page":"Low-order","title":"RKM.ImplicitTrapezoid2","text":"ImplicitTrapezoid2(precision::Type{T} = Float64) where T <: AbstractFloat\n\nSecond-order implicit trapezoid rule (A-stable).\n\n\n\n\n\n","category":"method"},{"location":"methods/runge_kutta/implicit/low_order.html#RKM.KraaijevangerSpijker2-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T<:AbstractFloat","page":"Low-order","title":"RKM.KraaijevangerSpijker2","text":"KraaijevangerSpijker2(precision::Type{T} = Float64) where T <: AbstractFloat\n\nKraaijevanger and Spijker's second-order method.\n\n\n\n\n\n","category":"method"},{"location":"methods/runge_kutta/implicit/low_order.html#RKM.PareschiRusso2-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T<:AbstractFloat","page":"Low-order","title":"RKM.PareschiRusso2","text":"PareschiRusso2(precision::Type{T} = Float64) where T <: AbstractFloat\n\nPareschi and Russo's second-order method.\n\n\n\n\n\n","category":"method"},{"location":"methods/runge_kutta/implicit/low_order.html#RKM.PareschiRusso3-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T<:AbstractFloat","page":"Low-order","title":"RKM.PareschiRusso3","text":"PareschiRusso3(precision::Type{T} = Float64) where T <: AbstractFloat\n\nPareschi and Russo's third-order method.\n\n\n\n\n\n","category":"method"},{"location":"methods/runge_kutta/implicit/low_order.html#RKM.QinZhang2-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T<:AbstractFloat","page":"Low-order","title":"RKM.QinZhang2","text":"QinZhang2(precision::Type{T} = Float64) where T <: AbstractFloat\n\nQin and Zhang's second-order method.\n\n\n\n\n\n","category":"method"},{"location":"methods/runge_kutta/implicit/low_order.html#RKM.RadauIA3-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T<:AbstractFloat","page":"Low-order","title":"RKM.RadauIA3","text":"RadauIA3(precision::Type{T} = Float64) where T <: AbstractFloat\n\nRadau IA3 third-order method.\n\n\n\n\n\n","category":"method"},{"location":"methods/runge_kutta/implicit/low_order.html#RKM.RadauIIA3-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T<:AbstractFloat","page":"Low-order","title":"RKM.RadauIIA3","text":"RadauIIA3(precision::Type{T} = Float64) where T <: AbstractFloat\n\nRadau IIA3 third-order method.\n\n\n\n\n\n","category":"method"},{"location":"methods/runge_kutta/implicit/low_order.html#RKM.TrapezoidRuleBDF2-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T<:AbstractFloat","page":"Low-order","title":"RKM.TrapezoidRuleBDF2","text":"TrapezoidRuleBDF2(precision::Type{T} = Float64) where T <: AbstractFloat\n\nSecond-order trapezoid rule BDF method (ABLS-stable)\n\nR.E. Bank, W.M. Coughran, W. Fichtner, E.H. Grosse, D.J. Rose, and R.K. Smith. Transient simulation of silicon devices and circuits. IEEE Transactions on Electron Devices, 32:1992– 2007, 1985.\n\n\n\n\n\n","category":"method"},{"location":"methods/runge_kutta/runge_kutta.html#Runge-Kutta-update","page":"Runge-Kutta update","title":"Runge-Kutta update","text":"","category":"section"},{"location":"methods/runge_kutta/runge_kutta.html","page":"Runge-Kutta update","title":"Runge-Kutta update","text":"fracdydt = f(ty)","category":"page"},{"location":"methods/runge_kutta/runge_kutta.html#Explicit-update","page":"Runge-Kutta update","title":"Explicit update","text":"","category":"section"},{"location":"methods/runge_kutta/runge_kutta.html","page":"Runge-Kutta update","title":"Runge-Kutta update","text":"Delta y_n^(s) = Delta t fBig(t_n + c_sDelta t y_n + sum_j=1^s-1 A_sj Delta y_n^(j)Big) \ny_n+1 = y_n + sum_s = 1^S b_s Delta y_n^(s)","category":"page"},{"location":"methods/runge_kutta/runge_kutta.html","page":"Runge-Kutta update","title":"Runge-Kutta update","text":"B_ij = 1","category":"page"},{"location":"methods/runge_kutta/debug_table.html#Debugging-the-Butcher-tableau","page":"Debugging the Butcher tableau","title":"Debugging the Butcher tableau","text":"","category":"section"},{"location":"methods/runge_kutta/debug_table.html#Testing-the-order-conditions","page":"Debugging the Butcher tableau","title":"Testing the order conditions","text":"","category":"section"},{"location":"methods/runge_kutta/debug_table.html","page":"Debugging the Butcher tableau","title":"Debugging the Butcher tableau","text":"The test file test/butcher_test.jl can be used to debug the Butcher tableau of each Runge-Kutta method to a certain extent. It checks whether or not the order conditions are satisfied within numerical precision:","category":"page"},{"location":"methods/runge_kutta/debug_table.html","page":"Debugging the Butcher tableau","title":"Debugging the Butcher tableau","text":"c_i = sum_j=1^S A_ij  forall  i \nsum_j=1^S b_j = 1 \nsum_j=1^S hatb_j = 1 ","category":"page"},{"location":"methods/runge_kutta/debug_table.html","page":"Debugging the Butcher tableau","title":"Debugging the Butcher tableau","text":"where S are the number of stages. Any individual stage that fails the test will register as either Broken or Fail, depending on how badly the condition is violated. This test is particularly important when using high-order methods with many coefficients and a high numerical precision is needed. To demonstrate, we validate the order conditions of the Feagin 14(12) method up to double-float precision:","category":"page"},{"location":"methods/runge_kutta/debug_table.html","page":"Debugging the Butcher tableau","title":"Debugging the Butcher tableau","text":"julia> using RKM\njulia> import DoubleFloats: Double64\njulia> method = Feagin14(; precision = Double64);\njulia> debug_table(method)\n#┌ Warning: |B[18,1] - ∑_{j>1} B[18,j]| = 7.7e-34 > 4.84e-34. Check row 18 in Feagin14.\n#└ @ RKM ~/Desktop/RKM.jl/src/methods/runge_kutta/debug_table.jl:50\n#┌ Warning: |B[20,1] - ∑_{j>1} B[20,j]| = 2.1e-31 > 1.8599999999999997e-31. Check row 20 in Feagin14.\n#└ @ RKM ~/Desktop/RKM.jl/src/methods/runge_kutta/debug_table.jl:50","category":"page"},{"location":"methods/runge_kutta/debug_table.html","page":"Debugging the Butcher tableau","title":"Debugging the Butcher tableau","text":"We see that two stages are broken, . However. We caution that this is. It may not detect a faulty row where the errors of multiple coefficients cancel out. defects in multiple coefficients per row whose errors cancel out.","category":"page"},{"location":"methods/runge_kutta/debug_table.html#API-Reference","page":"Debugging the Butcher tableau","title":"API Reference","text":"","category":"section"},{"location":"adaptive/algorithms/finite_diff.html#Finite-difference","page":"Finite difference","title":"Finite difference","text":"","category":"section"},{"location":"methods/runge_kutta/explicit/very_high_order.html#Very-high-order-(10)-explicit-Runge-Kutta-methods","page":"Very high-order","title":"Very high-order (10+) explicit Runge-Kutta methods","text":"","category":"section"},{"location":"methods/runge_kutta/explicit/very_high_order.html#Embedded","page":"Very high-order","title":"Embedded","text":"","category":"section"},{"location":"methods/runge_kutta/explicit/very_high_order.html","page":"Very high-order","title":"Very high-order","text":"The following embedded methods are compatible with all adaptive time step options:","category":"page"},{"location":"methods/runge_kutta/explicit/very_high_order.html","page":"Very high-order","title":"Very high-order","text":"Feagin10(): Feagin's tenth-order method\nFeagin12(): Feagin's twelfth-order method\nFeagin14(): Feagin's fourteenth-order method","category":"page"},{"location":"methods/runge_kutta/explicit/very_high_order.html#API-Reference","page":"Very high-order","title":"API Reference","text":"","category":"section"},{"location":"methods/runge_kutta/explicit/very_high_order.html#RKM.Feagin10-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T<:AbstractFloat","page":"Very high-order","title":"RKM.Feagin10","text":"Feagin10(precision::Type{T} = Float64) where T <: AbstractFloat\n\nFeagin's tenth-order method.\n\nhttp://www.peterstone.name/Maplepgs/RKcoeff.html\n\n\n\n\n\n","category":"method"},{"location":"methods/runge_kutta/explicit/very_high_order.html#RKM.Feagin12-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T<:AbstractFloat","page":"Very high-order","title":"RKM.Feagin12","text":"Feagin12(precision::Type{T} = Float64) where T <: AbstractFloat\n\nFeagin's twelfth-order method.\n\nhttp://www.peterstone.name/Maplepgs/Maple/nmthds/RKcoeff/RungeKuttaschemes/RK12/RKcoeff12a1.pdf https://github.com/drons/nbody/blob/6e90a2ee2fe21d3df60acaacbb9ecedb685e97cd/nbody/nbodysolver_rkfeagin12.cpp\n\n\n\n\n\n","category":"method"},{"location":"methods/runge_kutta/explicit/very_high_order.html#RKM.Feagin14-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T<:AbstractFloat","page":"Very high-order","title":"RKM.Feagin14","text":"Feagin14(precision::Type{T} = Float64) where T <: AbstractFloat\n\nFeagin's fourteenth-order method.\n\nhttp://www.peterstone.name/Maplepgs/Maple/nmthds/RKcoeff/RungeKuttaschemes/RK14/RKcoeff14a1.pdf https://github.com/drons/nbody/blob/6e90a2ee2fe21d3df60acaacbb9ecedb685e97cd/nbody/nbodysolver_rkfeagin14.cpp\n\n\n\n\n\n","category":"method"},{"location":"overview.html#Overview","page":"Overview","title":"Overview","text":"","category":"section"},{"location":"overview.html","page":"Overview","title":"Overview","text":"using RKM\nimport DoubleFloat\nusing Plots; plotly()\n\n# differential equation\nconst C = 0.5\nfunction dy_dt!(f, t, y)\n    f[1] = (y[1] + C) * (1.0 - C - y[1])\n    nothing\nend\n\n# initial conditions\nt0 = -10.0\ny0 = exp(t0)/(1.0 + exp(t0)) - C\n\n# time range, solver options\nt_range = TimeRange(; t0, tf = 10.0, dt0 = 1e-4)\noptions = SolverOptions(; t_range, method = RungeKutta4(), adaptive = Fixed())\n\n# evolve system\nsol = evolve_ode(y0, dy_dt!, options, precision = Float64)\n\n# plot solution\nt, y = get_solution(sol)\nplot(t, y)","category":"page"},{"location":"methods/runge_kutta/explicit/high_order.html#High-order-(7-9)-explicit-Runge-Kutta-methods","page":"High-order","title":"High-order (7-9) explicit Runge-Kutta methods","text":"","category":"section"},{"location":"methods/runge_kutta/explicit/high_order.html#Standard","page":"High-order","title":"Standard","text":"","category":"section"},{"location":"methods/runge_kutta/explicit/high_order.html","page":"High-order","title":"High-order","text":"The following standard methods are compatible with Fixed(), Doubling() and FiniteDiff() time-stepping:","category":"page"},{"location":"methods/runge_kutta/explicit/high_order.html","page":"High-order","title":"High-order","text":"Curtis8(): Curtis' eighth-order method\nShanks8(): Shanks' eighth-order method\nShanksPseudo8(): Shanks' pseudo eighth-order method","category":"page"},{"location":"methods/runge_kutta/explicit/high_order.html#Embedded","page":"High-order","title":"Embedded","text":"","category":"section"},{"location":"methods/runge_kutta/explicit/high_order.html","page":"High-order","title":"High-order","text":"The following embedded methods are compatible with all adaptive time step options:","category":"page"},{"location":"methods/runge_kutta/explicit/high_order.html","page":"High-order","title":"High-order","text":"Fehlberg7(): Fehlberg's seventh-order method\nDormandPrince8(): Dormand and Prince's eighth-order method","category":"page"},{"location":"methods/runge_kutta/explicit/high_order.html#API-Reference","page":"High-order","title":"API Reference","text":"","category":"section"},{"location":"methods/runge_kutta/explicit/high_order.html#RKM.Curtis8-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T<:AbstractFloat","page":"High-order","title":"RKM.Curtis8","text":"Curtis8(precision::Type{T} = Float64) where T <: AbstractFloat\n\nCurtis' eighth-order method.\n\nhttps://link.springer.com/article/10.1007/BF02219778 http://www.peterstone.name/Maplepgs/Maple/nmthds/RKcoeff/RungeKuttaschemes/RK8/RKcoeff8b_4.pdf\n\n\n\n\n\n","category":"method"},{"location":"methods/runge_kutta/explicit/high_order.html#RKM.DormandPrince8-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T<:AbstractFloat","page":"High-order","title":"RKM.DormandPrince8","text":"DormandPrince8(precision::Type{T} = Float64) where T <: AbstractFloat\n\nDormand and Prince's eighth-order method.\n\nhttps://www.sciencedirect.com/science/article/pii/0771050X81900103 http://www.peterstone.name/Maplepgs/Maple/nmthds/RKcoeff/RungeKuttaschemes/RK8/RKcoeff8d_1.pdf\n\n\n\n\n\n","category":"method"},{"location":"methods/runge_kutta/explicit/high_order.html#RKM.Fehlberg7-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T<:AbstractFloat","page":"High-order","title":"RKM.Fehlberg7","text":"Fehlberg7(precision::Type{T} = Float64) where T <: AbstractFloat\n\nFehlberg's seventh-order method.\n\nhttps://ntrs.nasa.gov/citations/19680027281\n\n\n\n\n\n","category":"method"},{"location":"methods/runge_kutta/explicit/high_order.html#RKM.Shanks8-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T<:AbstractFloat","page":"High-order","title":"RKM.Shanks8","text":"Shanks8(precision::Type{T} = Float64) where T <: AbstractFloat\n\nShanks' eighth-order method.\n\nhttps://ntrs.nasa.gov/citations/19650022581\n\n\n\n\n\n","category":"method"},{"location":"methods/runge_kutta/explicit/high_order.html#RKM.ShanksPseudo8-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T<:AbstractFloat","page":"High-order","title":"RKM.ShanksPseudo8","text":"ShanksPseudo8(precision::Type{T} = Float64) where T <: AbstractFloat\n\nShanks' pseudo eighth-order method.\n\nhttps://ntrs.nasa.gov/citations/19650022581\n\n\n\n\n\n","category":"method"},{"location":"adaptive/algorithms/embedded.html#Embedded","page":"Embedded","title":"Embedded","text":"","category":"section"},{"location":"index.html#RKM.jl","page":"Home","title":"RKM.jl","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"Intro nothing so far","category":"page"},{"location":"module.html#Module","page":"Module","title":"Module","text":"","category":"section"},{"location":"module.html#Exports","page":"Module","title":"Exports","text":"","category":"section"},{"location":"module.html","page":"Module","title":"Module","text":"evolve_ode for solving the ODE system and outputting the solution\nget_solution for post-processing the ODE solution\nSolverOptions for storing the ODE solver options\nTimeRange for specifying the time evolution interval\nTimeLimit for setting a timer for the solver routine\nRunge–Kutta methods (see Runge–Kutta)\nAdaptive time step options (see ...make a page...)","category":"page"},{"location":"module.html#Dependencies","page":"Module","title":"Dependencies","text":"","category":"section"},{"location":"module.html","page":"Module","title":"Module","text":"StaticArrays.jl: SVector, SMatrix and MVector for the static allocation of Butcher tableaus, state vectors and intermediate caches\nFastBroadcast.jl: @.. for broadcasting recurring element-wise operations in the state update routines\nProgressMeter.jl: Progress and next! for monitoring the real-time status of the solver routine","category":"page"},{"location":"module.html#External-modules","page":"Module","title":"External modules","text":"","category":"section"},{"location":"module.html","page":"Module","title":"Module","text":"DoubleFloats.jl: Double64 for runs that require quadruple-float precision\nBenchmarkTools.jl: @benchmark, @btime and mean for benchmarking solver runtime and memory usage","category":"page"},{"location":"module.html#RKM.evolve_ode!-Union{Tuple{T1}, Tuple{T}, Tuple{Solution{T1}, Vector{T}, T, Float64, Float64, Function, SolverOptions{T1}}, Tuple{Solution{T1}, Vector{T}, T, Float64, Float64, Function, SolverOptions{T1}, Vector{Float64}}} where {T<:AbstractFloat, T1<:AbstractFloat}","page":"Module","title":"RKM.evolve_ode!","text":"evolve_ode!(sol::Solution{T1}, y0::Vector{T}, t0::T, tf::Float64,\n            dt0::Float64, dy_dt!::Function, options::SolverOptions{T1},\n            p::Vector{Float64} = Float64[];\n            abstract_params = nothing) where {T <: AbstractFloat,\n                                              T1 <: AbstractFloat}\n\nRequired parameters: sol, y0, t0, tf,dt0,dy_dt!,options`\n\n\n\n\n\n","category":"method"},{"location":"module.html#RKM.evolve_ode-Union{Tuple{T1}, Tuple{T}, Tuple{Vector{T}, T, Float64, Float64, Function, SolverOptions{T1}}, Tuple{Vector{T}, T, Float64, Float64, Function, SolverOptions{T1}, Vector{Float64}}} where {T<:AbstractFloat, T1<:AbstractFloat}","page":"Module","title":"RKM.evolve_ode","text":"evolve_ode(y0::Vector{T}, t0::T, tf::Float64, dt0::Float64,\n           dy_dt!::Function, options::SolverOptions{T1},\n           p::Vector{Float64} = Float64[];\n           abstract_params = nothing) where {T <: AbstractFloat,\n                                                T1 <: AbstractFloat}\n\nRequired parameters: y0, t0, tf, dt0, dy_dt!, options\n\n\n\n\n\n","category":"method"},{"location":"module.html#RKM.TimeLimit","page":"Module","title":"RKM.TimeLimit","text":"Sets a timer for the ODE solver.\n\n\n\n\n\n","category":"type"},{"location":"module.html#RKM.TimeLimit-Tuple{}","page":"Module","title":"RKM.TimeLimit","text":"function TimeLimit(; wtime_min::Real = 60)\n\nOuter constructor for TimeLimit.\n\n\n\n\n\n","category":"method"},{"location":"module.html#RKM.continue_solver-Union{Tuple{T}, Tuple{Vector{T}, Vector{T}, T, TimeLimit, Bool}} where T<:AbstractFloat","page":"Module","title":"RKM.continue_solver","text":"continue_solver(t::Vector{T}, dt::Vector{T}, tf::T,\n                timer::TimeLimit, show_progress::Bool) where T <: AbstractFloat\n\nChecks whether to continue running the ODE solver. The solver stops if the simulation finishes, the runtime exceeds the limit set by timer or the time step is too small.\n\nRequired parameters: t, dt, tf, timer, show_progress\n\n\n\n\n\n","category":"method"},{"location":"module.html#RKM.reset_timer!-Tuple{TimeLimit}","page":"Module","title":"RKM.reset_timer!","text":"reset_timer!(timer::TimeLimit)\n\nResets the timer fields to the values given by the TimeLimit outer constructor\n\nRequired parameters: timer\n\n\n\n\n\n","category":"method"},{"location":"module.html#RKM.nansafe_state_jacobian-Union{Tuple{T1}, Tuple{T}, Tuple{Vector{T}, T1, Function}, Tuple{Vector{T}, T1, Function, Vector{Float64}}} where {T<:AbstractFloat, T1<:AbstractFloat}","page":"Module","title":"RKM.nansafe_state_jacobian","text":"nansafe_state_jacobian(y0::Vector{T}, t0::T1, dy_dt!::Function,\n                       p::Vector{Float64} = Float64[];\n                       chunk_size::Int64 = DEFAULT_CHUNK_THRESHOLD,\n                       abstract_params = nothing) where {T <: AbstractFloat,\n                                                         T1 <: AbstractFloat}\n\nEstimates the sparsity pattern of the state-Jacobian J = df/dy via forward-mode auto-differentiation. The Jacobian is evaluated at y = NaN, which only works if NANSAFEMODEENABLED = true in ForwardDiff.jl. Reducing the chunk size can help remove excess matrix elements from the sparsity pattern. For more details see https://juliadiff.org/ForwardDiff.jl/stable/user/advanced/.\n\nNote: some nonzero matrix elements may be missed if dy_dt! removes traces of       the dual number y = Dual(NaN, 1.0). For example, the following subroutines       do this:\n\n    z = isnan(y) ? zero(y) : y  # Dual(0.0, 0.0)\n    z = max(y, 0.0)             # Dual(NaN, 0.0)\n    z = min(0.0, y)             # Dual(NaN, 0.0)\n\nRequired parameters: y0, t0, dy_dt!\n\nOptional parameters: p, chunk_size, abstract_params\n\n\n\n\n\n","category":"method"},{"location":"module.html#RKM.SolverOptions","page":"Module","title":"RKM.SolverOptions","text":"SolverOptions for the ODE solver.\n\n\n\n\n\n","category":"type"},{"location":"module.html#RKM.plot_ode-Tuple{Solution, SolverOptions, Function}","page":"Module","title":"RKM.plot_ode","text":"plot_ode(sol::Solution, options::SolverOptions, plot::Function;\n         logx = false, logy = false, show_time_step = false)\n\nPlots the ODE solution y(t) from sol with the function plot (usually Plots.plot).\n\nNote: pass plot as a function to reduce RKM's precompilation time.\n\n\n\n\n\n","category":"method"},{"location":"module.html#RKM.reconstruct_method-Union{Tuple{T}, Tuple{RKM.ODEMethod, Type{T}}} where T<:AbstractFloat","page":"Module","title":"RKM.reconstruct_method","text":"reconstruct_method(method::ODEMethod, precision::Type{T}) where T <: AbstractFloat\n\nReconstructs the ODE method (i.e. tables) with the prescribed numerical precision.\n\nRequired parameters: method, precision\n\n\n\n\n\n","category":"method"},{"location":"module.html#RKM.AdamsBashforth-Union{Tuple{}, Tuple{T}} where T<:AbstractFloat","page":"Module","title":"RKM.AdamsBashforth","text":"AdamsBashforth(; order::Int64, precision::Type{T} = Float64,\n                 start_method::RungeKutta = Ketcheson4()) where T <: AbstractFloat\n\nAdams-Bashforth (AB) explicit multistep method.\n\nNote: order ranges from 1-6\n\n\n\n\n\n","category":"method"},{"location":"module.html#RKM.AdamsMoulton-Union{Tuple{}, Tuple{T}} where T<:AbstractFloat","page":"Module","title":"RKM.AdamsMoulton","text":"AdamsMoulton(; order::Int64, precision::Type{T} = Float64,\n               start_method::RungeKutta = Ketcheson4()) where T <: AbstractFloat\n\nAdams-Moulton (AM) implicit multistep method.\n\nNote: order ranges from 1-6, table_pred contains the        predictor coefficients (i.e. Adams-Bashforth)\n\n\n\n\n\n","category":"method"},{"location":"module.html#RKM.BackwardDifferentiationFormula-Union{Tuple{}, Tuple{T}} where T<:AbstractFloat","page":"Module","title":"RKM.BackwardDifferentiationFormula","text":"BackwardDifferentiationFormula(; order::Int64,\n    precision::Type{T} = Float64) where T <: AbstractFloat\n\nBackward differentiation formula (BDF) implicit multistep method.\n\nNote: order ranges from 1-6, table_pred contains the predictor coefficients\n\n\n\n\n\n","category":"method"},{"location":"module.html#RKM.NumericalDifferentiationFormula-Union{Tuple{}, Tuple{T}} where T<:AbstractFloat","page":"Module","title":"RKM.NumericalDifferentiationFormula","text":"NumericalDifferentiationFormula(; order::Int64,\n    precision::Type{T} = Float64) where T <: AbstractFloat\n\nNumerical differentiation formula (NDF) implicit multistep method.\n\nNote: order ranges from 1-4, table_pred contains the predictor coefficients\n\n\n\n\n\n","category":"method"},{"location":"module.html#RKM.monitor_progress-Union{Tuple{T}, Tuple{ProgressMeter.Progress, Vector{T}, Vector{T}, TimeLimit, Vector{T}}} where T<:AbstractFloat","page":"Module","title":"RKM.monitor_progress","text":"monitor_progress(progress::Progress, checkpoints::Vector{T},\n                 t::Vector{T}, timer::TimeLimit, dt::Vector{T})\n\nUpdates the progress bar percentage points if the current time t has passed any checkpoints. ODE variables and solver stats are also displayed in real time.\n\nRequired parameters: progress, checkpoints, t, timer, dt\n\n\n\n\n\n","category":"method"},{"location":"module.html#RKM.get_fesal-Union{Tuple{T}, Tuple{S2}, Tuple{S}, Tuple{StaticArraysCore.SMatrix{S, S, T, S2}, StaticArraysCore.SVector{S, T}, StaticArraysCore.SVector{S, T}}} where {S, S2, T<:AbstractFloat}","page":"Module","title":"RKM.get_fesal","text":"get_fesal(A_T::SMatrix{S, S, T, S2}, b::SVector{S, T},\n          c::SVector{S, T}) where {S, S2, T <: AbstractFloat}\n\nChecks whether the Runge-Kutta method has the First Explicit Same As Last (FESAL) property. The boolean fesal is set true if the last stage is equal to an explicit first stage evaluated at the next time step.\n\nUnlike the conventional First Same As Last (FSAL) property, FESAL does not require that the first stage of the Butcher tableau is explicit. Therefore, some implicit Runge-Kutta methods like BackwardEuler1 are allowed to reuse the last stage for Hermite interpolation.\n\nRequired parameters: A_T, b, c\n\n\n\n\n\n","category":"method"}]
}
